// FadedBalancerOFX.dctl v1.2.0
// --------------------------------------------------------------
// DaVinci Resolve DCTL OFX plugin for balancing RGB channels in
// faded or color-imbalanced film scans. Provides accessible and 
// flexible tools for channel adjustment, mixing, copy, and removal.
// Developed by Fabio Bedoya. Licensed under MIT.
//
// Contributors: Please keep comments clear and sections organized
// for ease of collaboration and user accessibility.
// --------------------------------------------------------------


// =============================
//         UI PARAMETERS
// =============================

// --------- Section: Film Fade Correction ---------
DEFINE_UI_PARAMS(fadeCorrection, Fade Correction, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)

// --------- Channel Balance ---------
// Controls for adjusting the balance of each color channel.
// "Shadows" (lift), "Midtones" (gamma), and "Highlights" (gain) for each channel.

DEFINE_UI_PARAMS(globalShadows,      Global Shadows,     DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(globalMidtones,     Global Midtones,    DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(globalHighlights,   Global Highlights,  DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)

// --------- Section: Channel Mixing ---------
// Logical toggle for user interface grouping.
DEFINE_UI_PARAMS(channelMixingSection, -- CHANNEL MIXING --, DCTLUI_CHECK_BOX, 0)

// Red Channel Mixing
DEFINE_UI_PARAMS(enableMinRedGreen,   Red: Darken with Green,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMinRedBlue,    Red: Darken with Blue,     DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxRedGreen,   Red: Lighten with Green,   DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxRedBlue,    Red: Lighten with Blue,    DCTLUI_CHECK_BOX, 0)

// Green Channel Mixing
DEFINE_UI_PARAMS(enableMinGreenRed,   Green: Darken with Red,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMinGreenBlue,  Green: Darken with Blue,   DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxGreenRed,   Green: Lighten with Red,   DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxGreenBlue,  Green: Lighten with Blue,  DCTLUI_CHECK_BOX, 0)

// Blue Channel Mixing
DEFINE_UI_PARAMS(enableMinBlueRed,    Blue: Darken with Red,     DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMinBlueGreen,  Blue: Darken with Green,   DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxBlueRed,    Blue: Lighten with Red,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enableMaxBlueGreen,  Blue: Lighten with Green,  DCTLUI_CHECK_BOX, 0)

// Channel Balance controls for each color channel
DEFINE_UI_PARAMS(redOffset,       Red Offset,         DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(redShadows,      Red Shadows,        DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(redMidtones,     Red Midtones,       DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(redHighlights,   Red Highlights,     DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)

DEFINE_UI_PARAMS(greenOffset,     Green Offset,       DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(greenShadows,    Green Shadows,      DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(greenMidtones,   Green Midtones,     DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(greenHighlights, Green Highlights,   DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)

DEFINE_UI_PARAMS(blueOffset,      Blue Offset,        DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(blueShadows,     Blue Shadows,       DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(blueMidtones,    Blue Midtones,      DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(blueHighlights,  Blue Highlights,    DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)

// --------- Section: Channel Copy ---------
// Grouping control for channel copy features.
DEFINE_UI_PARAMS(enableChannelCopy, -- CHANNEL COPY --, DCTLUI_CHECK_BOX, 0)

// Red Channel Copy
DEFINE_UI_PARAMS(copyGreenToRed,  Copy Green to Red,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(copyBlueToRed,   Copy Blue to Red,     DCTLUI_CHECK_BOX, 0)

// Green Channel Copy
DEFINE_UI_PARAMS(copyRedToGreen,  Copy Red to Green,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(copyBlueToGreen, Copy Blue to Green,   DCTLUI_CHECK_BOX, 0)

// Blue Channel Copy
DEFINE_UI_PARAMS(copyRedToBlue,   Copy Red to Blue,     DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(copyGreenToBlue, Copy Green to Blue,   DCTLUI_CHECK_BOX, 0)

// --------- Section: Channel Removal ---------
// Grouping control for channel removal features.
DEFINE_UI_PARAMS(enableChannelRemoval, -- CHANNEL REMOVAL --, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(removeRed,     Remove Red,    DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(removeGreen,   Remove Green,  DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(removeBlue,    Remove Blue,   DCTLUI_CHECK_BOX, 0)

// --------- Section: Output Transform ---------
DEFINE_UI_PARAMS(outputToCineon, Output to Cineon Log, DCTLUI_CHECK_BOX, 0)


// =============================
//      HELPER FUNCTIONS
// =============================

// Clamp value to the [0,1] range for safe channel operations.
__DEVICE__ float clamp01(float x) {
    return _fminf(_fmaxf(x, 0.0f), 1.0f);
}

// Safe power function for gamma correction, avoids NaNs for low values.
__DEVICE__ float safe_pow(float x, float y) {
    return _powf(_fmaxf(x, 1e-9f), y);
}

// LGGO (Lift, Gamma, Gain/Highlights, Offset) processing for each channel.
// Applies shadows, midtones, highlights in an RGB vector.
__DEVICE__ float3 applyLGGO(float3 col, float3 offset, float3 shadows, float3 midtones, float3 highlights) {
    col += offset;
    col += shadows;

    col.x = safe_pow(col.x, 1.0f / midtones.x);
    col.y = safe_pow(col.y, 1.0f / midtones.y);
    col.z = safe_pow(col.z, 1.0f / midtones.z);

    col = col * highlights;

    return col;
}

// Applies an adaptive saturation and contrast enhancement to correct faded footage.
// The approach is partially inspired by insights from "Digital Unfading of Chromogenic Film Informed by Its Spectral Densities" by G. Trumpy et al.
// https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/3101572
__DEVICE__ float3 applyFadeCorrection(float3 col, float fadeCorrection) {
    if (fadeCorrection > 0.0f) {
        float luma = col.x * 0.2126f + col.y * 0.7152f + col.z * 0.0722f;

        // --- Contrast Enhancement ---
        // Apply a gentle S-curve for contrast
        float contrastedLuma = luma * luma * (3.0f - 2.0f * luma);
        
        // Mix between original luma and contrasted luma
        float finalLuma = _mix(luma, contrastedLuma, fadeCorrection);

        // --- Adaptive Saturation ---
        float3 lumaColor = make_float3(luma, luma, luma);
        // The amount of saturation to add
        float satAmount = 1.0f + fadeCorrection;
        
        // Mix between grayscale and original color to control saturation
        float3 saturatedCol = _mix(lumaColor, col, satAmount);

        // --- Combine and apply ---
        // First, apply saturation
        col = _mix(col, saturatedCol, fadeCorrection);
        
        // Then, apply contrast, preserving hue
        float newLuma = col.x * 0.2126f + col.y * 0.7152f + col.z * 0.0722f;
        if (newLuma > 1e-9f) {
            col *= finalLuma / newLuma;
        }
    }
    return col;
}

// Converts a linear float value to Cineon Log.
__DEVICE__ float linearToCineon(float linear) {
    if (linear <= 0.0f) {
        return -1.0e+10f; // Represents negative infinity in Cineon
    }
    return (1023.0f * (0.30102999566 * _log10f(linear * 0.9f) + 0.66666666667)) / 1023.0f;
}


// =============================
//         MAIN ENTRY POINT
// =============================

// This is the main processing function for each pixel.
// All controls and channel operations are handled in sequence for clarity and extensibility.
__DEVICE__ float4 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B, float p_A)
{
    float3 rgb = make_float3(p_R, p_G, p_B);

    // --- Film Fade Correction ---
    rgb = applyFadeCorrection(rgb, fadeCorrection);

    // --- Global Channel Balance (Lift/Gamma/Gain) ---
    rgb += globalShadows;
    rgb.x = safe_pow(rgb.x, 1.0f / globalMidtones);
    rgb.y = safe_pow(rgb.y, 1.0f / globalMidtones);
    rgb.z = safe_pow(rgb.z, 1.0f / globalMidtones);
    rgb *= globalHighlights;

    // --- Per-Channel Balance ---
    float3 offset      = make_float3(redOffset, greenOffset, blueOffset);
    float3 shadows     = make_float3(redShadows, greenShadows, blueShadows);
    float3 midtones    = make_float3(redMidtones, greenMidtones, blueMidtones);
    float3 highlights  = make_float3(redHighlights, greenHighlights, blueHighlights);

    rgb = applyLGGO(rgb, offset, shadows, midtones, highlights);

    // --- Channel Copy Section ---
    if (enableChannelCopy > 0.5f) {
        // Red
        if (copyGreenToRed  > 0.5f) rgb.x = rgb.y;
        if (copyBlueToRed   > 0.5f) rgb.x = rgb.z;
        // Green
        if (copyRedToGreen  > 0.5f) rgb.y = rgb.x;
        if (copyBlueToGreen > 0.5f) rgb.y = rgb.z;
        // Blue
        if (copyRedToBlue   > 0.5f) rgb.z = rgb.x;
        if (copyGreenToBlue > 0.5f) rgb.z = rgb.y;
    }

    // --- Channel Removal Section ---
    if (enableChannelRemoval > 0.5f) {
        if (removeRed   > 0.5f) rgb.x = 0.0f;
        if (removeGreen > 0.5f) rgb.y = 0.0f;
        if (removeBlue  > 0.5f) rgb.z = 0.0f;
    }

    // --- Channel Mixing Section ---
    if (channelMixingSection > 0.5f) {
        // Red min/max
        if (enableMinRedGreen > 0.5f)   rgb.x = _fminf(rgb.x, rgb.y); // Red = min(R, G)
        if (enableMinRedBlue > 0.5f)    rgb.x = _fminf(rgb.x, rgb.z); // Red = min(R, B)
        if (enableMaxRedGreen > 0.5f)   rgb.x = _fmaxf(rgb.x, rgb.y); // Red = max(R, G)
        if (enableMaxRedBlue > 0.5f)    rgb.x = _fmaxf(rgb.x, rgb.z); // Red = max(R, B)

        // Green min/max
        if (enableMinGreenRed > 0.5f)   rgb.y = _fminf(rgb.y, rgb.x); // Green = min(G, R)
        if (enableMinGreenBlue > 0.5f)  rgb.y = _fminf(rgb.y, rgb.z); // Green = min(G, B)
        if (enableMaxGreenRed > 0.5f)   rgb.y = _fmaxf(rgb.y, rgb.x); // Green = max(G, R)
        if (enableMaxGreenBlue > 0.5f)  rgb.y = _fmaxf(rgb.y, rgb.z); // Green = max(G, B)

        // Blue min/max
        if (enableMinBlueRed > 0.5f)    rgb.z = _fminf(rgb.z, rgb.x); // Blue = min(B, R)
        if (enableMinBlueGreen > 0.5f)  rgb.z = _fminf(rgb.z, rgb.y); // Blue = min(B, G)
        if (enableMaxBlueRed > 0.5f)    rgb.z = _fmaxf(rgb.z, rgb.x); // Blue = max(B, R)
        if (enableMaxBlueGreen > 0.5f)  rgb.z = _fmaxf(rgb.z, rgb.y); // Blue = max(B, G)
    }

    // --- Output Transform ---
    if (outputToCineon > 0.5f) {
        rgb.x = linearToCineon(rgb.x);
        rgb.y = linearToCineon(rgb.y);
        rgb.z = linearToCineon(rgb.z);
    }

    return make_float4(rgb.x, rgb.y, rgb.z, p_A);
}
