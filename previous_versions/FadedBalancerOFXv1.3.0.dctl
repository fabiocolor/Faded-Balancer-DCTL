// FadedBalancerOFX v1.3.0
// Corrective RGB rebalance for faded / color‑shifted film scans.
// Pipeline: Global -> Fade Fix -> Per-Channel -> Mix (Darken/Lighten) -> Replace -> Remove -> Output (optional Cineon).
// Preserve Luminance applies ONLY to per‑channel stage.

// === UI PARAMETERS ===

// Global controls
DEFINE_UI_PARAMS(fadeCorrection, ✨ Fade Correction, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(globalOffset,   🌐 Global Offset,   DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(globalShadows,  🌑 Global Shadows,  DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(globalMidtones, 🌓 Global Midtones, DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(globalHighlights, 🌕 Global Highlights, DCTLUI_SLIDER_FLOAT, 1.0, 0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(preserveLuminance, ⚖️ Preserve Luminance, DCTLUI_CHECK_BOX, 0)

// Per‑channel controls
DEFINE_UI_PARAMS(redOffset,     🔴 Red Offset,     DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(redShadows,    🔴 Red Shadows,    DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(redMidtones,   🔴 Red Midtones,   DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(redHighlights, 🔴 Red Highlights, DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(greenOffset,     🟢 Green Offset,     DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(greenShadows,    🟢 Green Shadows,    DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(greenMidtones,   🟢 Green Midtones,   DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(greenHighlights, 🟢 Green Highlights, DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(blueOffset,     🔵 Blue Offset,     DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(blueShadows,    🔵 Blue Shadows,    DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(blueMidtones,   🔵 Blue Midtones,   DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)
DEFINE_UI_PARAMS(blueHighlights, 🔵 Blue Highlights, DCTLUI_SLIDER_FLOAT, 1.0,  0.1, 3.0, 0.001)

// Channel mixing (darken/lighten composites)
DEFINE_UI_PARAMS(redDarkenWith,   🔴🌙 Red Darken,   DCTLUI_COMBO_BOX, 0, { RDW_NONE, RDW_GREEN, RDW_BLUE }, { None, With Green, With Blue })
DEFINE_UI_PARAMS(redLightenWith,  🔴☀️ Red Lighten,  DCTLUI_COMBO_BOX, 0, { RLW_NONE, RLW_GREEN, RLW_BLUE }, { None, With Green, With Blue })
DEFINE_UI_PARAMS(greenDarkenWith, 🟢🌙 Green Darken, DCTLUI_COMBO_BOX, 0, { GDW_NONE, GDW_RED, GDW_BLUE }, { None, With Red, With Blue })
DEFINE_UI_PARAMS(greenLightenWith, 🟢☀️ Green Lighten, DCTLUI_COMBO_BOX, 0, { GLW_NONE, GLW_RED, GLW_BLUE }, { None, With Red, With Blue })
DEFINE_UI_PARAMS(blueDarkenWith,  🔵🌙 Blue Darken,  DCTLUI_COMBO_BOX, 0, { BDW_NONE, BDW_RED, BDW_GREEN }, { None, With Red, With Green })
DEFINE_UI_PARAMS(blueLightenWith, 🔵☀️ Blue Lighten, DCTLUI_COMBO_BOX, 0, { BLW_NONE, BLW_RED, BLW_GREEN }, { None, With Red, With Green })

// Replace / removal / output
DEFINE_UI_PARAMS(copyRedSource,   🔴↔ Replace Red,   DCTLUI_COMBO_BOX, 0, { CR_NONE, CR_FROM_GREEN, CR_FROM_BLUE }, { None, With Green, With Blue })
DEFINE_UI_PARAMS(copyGreenSource, 🟢↔ Replace Green, DCTLUI_COMBO_BOX, 0, { CG_NONE, CG_FROM_RED, CG_FROM_BLUE }, { None, With Red, With Blue })
DEFINE_UI_PARAMS(copyBlueSource,  🔵↔ Replace Blue,  DCTLUI_COMBO_BOX, 0, { CB_NONE, CB_FROM_RED, CB_FROM_GREEN }, { None, With Red, With Green })
DEFINE_UI_PARAMS(channelRemovalMode, 🗑️ Channel Removal, DCTLUI_COMBO_BOX, 0, { REM_NONE, REM_RED, REM_GREEN, REM_BLUE, REM_ALL }, { None, Remove Red, Remove Green, Remove Blue, Remove All })
DEFINE_UI_PARAMS(outputToCineon, 🎞️ Output to Cineon Log, DCTLUI_CHECK_BOX, 0)


// === HELPERS ===

__DEVICE__ float safe_pow(float x, float y) { return _powf(_fmaxf(x, 1e-9f), y); }

__DEVICE__ float3 applyLGGO(float3 col, float3 offset, float3 shadows, float3 midtones, float3 highlights) {
    col += offset;
    col += shadows;
    col.x = safe_pow(col.x, 1.0f / midtones.x);
    col.y = safe_pow(col.y, 1.0f / midtones.y);
    col.z = safe_pow(col.z, 1.0f / midtones.z);
    col *= highlights;
    return col;
}

__DEVICE__ float3 applyFadeCorrection(float3 col, float fadeCorrection) {
    if (fadeCorrection > 0.0f) {
        float luma = col.x * 0.2126f + col.y * 0.7152f + col.z * 0.0722f;
        float contrastedLuma = luma * luma * (3.0f - 2.0f * luma);
        float finalLuma = _mix(luma, contrastedLuma, fadeCorrection);
        float3 lumaColor = make_float3(luma, luma, luma);
        float satAmount = 1.0f + fadeCorrection;
        float3 saturatedCol = _mix(lumaColor, col, satAmount);
        col = _mix(col, saturatedCol, fadeCorrection);
        float newLuma = col.x * 0.2126f + col.y * 0.7152f + col.z * 0.0722f;
        if (newLuma > 1e-9f) col *= finalLuma / newLuma;
    }
    return col;
}

__DEVICE__ float linearToCineon(float linear) {
    if (linear <= 0.0f) return -1.0e+10f; // negative infinity representation
    return (1023.0f * (0.30102999566 * _log10f(linear * 0.9f) + 0.66666666667)) / 1023.0f;
}


// === MAIN TRANSFORM === (signature as required by Resolve)
__DEVICE__ float4 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B, float p_A) {
    // (p_Width, p_Height, p_X, p_Y) not used in this effect; retained to satisfy required signature.
    float3 rgb = make_float3(p_R, p_G, p_B);

    // 1. Global Adjust (allowed to change luminance)
    rgb = applyLGGO(rgb,
        make_float3(globalOffset, globalOffset, globalOffset),
        make_float3(globalShadows, globalShadows, globalShadows),
        make_float3(globalMidtones, globalMidtones, globalMidtones),
        make_float3(globalHighlights, globalHighlights, globalHighlights));

    // 2. Fade Correction
    rgb = applyFadeCorrection(rgb, fadeCorrection);

    // Capture luma before per-channel adjustments for optional preservation.
    float preChannelLuma = rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;

    // 3. Per-Channel Adjust (optionally preserve luminance after this stage)
    rgb = applyLGGO(rgb,
        make_float3(redOffset, greenOffset, blueOffset),
        make_float3(redShadows, greenShadows, blueShadows),
        make_float3(redMidtones, greenMidtones, blueMidtones),
        make_float3(redHighlights, greenHighlights, blueHighlights));
    if (preserveLuminance > 0.5f) {
        float postChannelLuma = rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;
        if (postChannelLuma > 1e-9f) rgb *= preChannelLuma / postChannelLuma;
    }

    // 4. Mixing (Darken / Lighten)
    if (redDarkenWith == RDW_GREEN) rgb.x = _fminf(rgb.x, rgb.y); else if (redDarkenWith == RDW_BLUE) rgb.x = _fminf(rgb.x, rgb.z);
    if (redLightenWith == RLW_GREEN) rgb.x = _fmaxf(rgb.x, rgb.y); else if (redLightenWith == RLW_BLUE) rgb.x = _fmaxf(rgb.x, rgb.z);
    if (greenDarkenWith == GDW_RED) rgb.y = _fminf(rgb.y, rgb.x); else if (greenDarkenWith == GDW_BLUE) rgb.y = _fminf(rgb.y, rgb.z);
    if (greenLightenWith == GLW_RED) rgb.y = _fmaxf(rgb.y, rgb.x); else if (greenLightenWith == GLW_BLUE) rgb.y = _fmaxf(rgb.y, rgb.z);
    if (blueDarkenWith == BDW_RED) rgb.z = _fminf(rgb.z, rgb.x); else if (blueDarkenWith == BDW_GREEN) rgb.z = _fminf(rgb.z, rgb.y);
    if (blueLightenWith == BLW_RED) rgb.z = _fmaxf(rgb.z, rgb.x); else if (blueLightenWith == BLW_GREEN) rgb.z = _fmaxf(rgb.z, rgb.y);

    // 5. Copy
    if (copyRedSource == CR_FROM_GREEN) rgb.x = rgb.y; else if (copyRedSource == CR_FROM_BLUE) rgb.x = rgb.z;
    if (copyGreenSource == CG_FROM_RED) rgb.y = rgb.x; else if (copyGreenSource == CG_FROM_BLUE) rgb.y = rgb.z;
    if (copyBlueSource == CB_FROM_RED) rgb.z = rgb.x; else if (copyBlueSource == CB_FROM_GREEN) rgb.z = rgb.y;

    // 6. Removal
    if (channelRemovalMode == REM_RED || channelRemovalMode == REM_ALL) rgb.x = 0.0f;
    if (channelRemovalMode == REM_GREEN || channelRemovalMode == REM_ALL) rgb.y = 0.0f;
    if (channelRemovalMode == REM_BLUE || channelRemovalMode == REM_ALL) rgb.z = 0.0f;

    // 7. Output
    if (outputToCineon > 0.5f) {
        rgb.x = linearToCineon(rgb.x);
        rgb.y = linearToCineon(rgb.y);
        rgb.z = linearToCineon(rgb.z);
    }
    return make_float4(rgb.x, rgb.y, rgb.z, p_A);
}
